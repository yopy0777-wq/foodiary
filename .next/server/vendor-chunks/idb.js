"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/idb";
exports.ids = ["vendor-chunks/idb"];
exports.modules = {

/***/ "(ssr)/./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: () => (/* binding */ deleteDB),\n/* harmony export */   openDB: () => (/* binding */ openDB),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors)=>constructors.some((c)=>object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return idbProxyableTypes || (idbProxyableTypes = [\n        IDBDatabase,\n        IDBObjectStore,\n        IDBIndex,\n        IDBCursor,\n        IDBTransaction\n    ]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\n        IDBCursor.prototype.advance,\n        IDBCursor.prototype.continue,\n        IDBCursor.prototype.continuePrimaryKey\n    ]);\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            request.removeEventListener(\"success\", success);\n            request.removeEventListener(\"error\", error);\n        };\n        const success = ()=>{\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = ()=>{\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener(\"success\", success);\n        request.addEventListener(\"error\", error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx)) return;\n    const done = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            tx.removeEventListener(\"complete\", complete);\n            tx.removeEventListener(\"error\", error);\n            tx.removeEventListener(\"abort\", error);\n        };\n        const complete = ()=>{\n            resolve();\n            unlisten();\n        };\n        const error = ()=>{\n            reject(tx.error || new DOMException(\"AbortError\", \"AbortError\"));\n            unlisten();\n        };\n        tx.addEventListener(\"complete\", complete);\n        tx.addEventListener(\"error\", error);\n        tx.addEventListener(\"abort\", error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get (target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === \"done\") return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === \"store\") {\n                return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set (target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has (target, prop) {\n        if (target instanceof IDBTransaction && (prop === \"done\" || prop === \"store\")) {\n            return true;\n        }\n        return prop in target;\n    }\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function(...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function(...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === \"function\") return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest) return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value)) return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value)=>reverseTransformCache.get(value);\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */ function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener(\"upgradeneeded\", (event)=>{\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener(\"blocked\", (event)=>blocked(// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n            event.oldVersion, event.newVersion, event));\n    }\n    openPromise.then((db)=>{\n        if (terminated) db.addEventListener(\"close\", ()=>terminated());\n        if (blocking) {\n            db.addEventListener(\"versionchange\", (event)=>blocking(event.oldVersion, event.newVersion, event));\n        }\n    }).catch(()=>{});\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */ function deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener(\"blocked\", (event)=>blocked(// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n            event.oldVersion, event));\n    }\n    return wrap(request).then(()=>undefined);\n}\nconst readMethods = [\n    \"get\",\n    \"getKey\",\n    \"getAll\",\n    \"getAllKeys\",\n    \"count\"\n];\nconst writeMethods = [\n    \"put\",\n    \"add\",\n    \"delete\",\n    \"clear\"\n];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === \"string\")) {\n        return;\n    }\n    if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, \"\");\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (// Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function(storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? \"readwrite\" : \"readonly\");\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps)=>({\n        ...oldTraps,\n        get: (target, prop, receiver)=>getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n        has: (target, prop)=>!!getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\nconst advanceMethodProps = [\n    \"continue\",\n    \"continuePrimaryKey\",\n    \"advance\"\n];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get (target, prop) {\n        if (!advanceMethodProps.includes(prop)) return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function(...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    }\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor) return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while(cursor){\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return prop === Symbol.asyncIterator && instanceOfAny(target, [\n        IDBIndex,\n        IDBObjectStore,\n        IDBCursor\n    ]) || prop === \"iterate\" && instanceOfAny(target, [\n        IDBIndex,\n        IDBObjectStore\n    ]);\n}\nreplaceTraps((oldTraps)=>({\n        ...oldTraps,\n        get (target, prop, receiver) {\n            if (isIteratorProp(target, prop)) return iterate;\n            return oldTraps.get(target, prop, receiver);\n        },\n        has (target, prop) {\n            return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n        }\n    }));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUlDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRO1lBQ3RCLElBQUkrRCxlQUFlakUsUUFBUUMsT0FDdkIsT0FBTzJEO1lBQ1gsT0FBT1AsU0FBU3RELEdBQUcsQ0FBQ0MsUUFBUUMsTUFBTUM7UUFDdEM7UUFDQVIsS0FBSU0sTUFBTSxFQUFFQyxJQUFJO1lBQ1osT0FBT2dFLGVBQWVqRSxRQUFRQyxTQUFTb0QsU0FBUzNELEdBQUcsQ0FBQ00sUUFBUUM7UUFDaEU7SUFDSjtBQUUwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zvb2QtZGlhcnktcHdhLy4vbm9kZV9tb2R1bGVzL2lkYi9idWlsZC9pbmRleC5qcz85MTM0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGluc3RhbmNlT2ZBbnkgPSAob2JqZWN0LCBjb25zdHJ1Y3RvcnMpID0+IGNvbnN0cnVjdG9ycy5zb21lKChjKSA9PiBvYmplY3QgaW5zdGFuY2VvZiBjKTtcblxubGV0IGlkYlByb3h5YWJsZVR5cGVzO1xubGV0IGN1cnNvckFkdmFuY2VNZXRob2RzO1xuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRJZGJQcm94eWFibGVUeXBlcygpIHtcbiAgICByZXR1cm4gKGlkYlByb3h5YWJsZVR5cGVzIHx8XG4gICAgICAgIChpZGJQcm94eWFibGVUeXBlcyA9IFtcbiAgICAgICAgICAgIElEQkRhdGFiYXNlLFxuICAgICAgICAgICAgSURCT2JqZWN0U3RvcmUsXG4gICAgICAgICAgICBJREJJbmRleCxcbiAgICAgICAgICAgIElEQkN1cnNvcixcbiAgICAgICAgICAgIElEQlRyYW5zYWN0aW9uLFxuICAgICAgICBdKSk7XG59XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkge1xuICAgIHJldHVybiAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgfHxcbiAgICAgICAgKGN1cnNvckFkdmFuY2VNZXRob2RzID0gW1xuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWVQcmltYXJ5S2V5LFxuICAgICAgICBdKSk7XG59XG5jb25zdCB0cmFuc2FjdGlvbkRvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHByb21pc2lmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwKHJlcXVlc3QucmVzdWx0KSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgbWFwcGluZyBleGlzdHMgaW4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGJ1dCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIE1ha2UgdHguc3RvcmUgcmV0dXJuIHRoZSBvbmx5IHN0b3JlIGluIHRoZSB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBtYW55LlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdzdG9yZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1sxXVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVyLm9iamVjdFN0b3JlKHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UgdHJhbnNmb3JtIHdoYXRldmVyIHdlIGdldCBiYWNrLlxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXRbcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICAgIChwcm9wID09PSAnZG9uZScgfHwgcHJvcCA9PT0gJ3N0b3JlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHJlcGxhY2VUcmFwcyhjYWxsYmFjaykge1xuICAgIGlkYlByb3h5VHJhcHMgPSBjYWxsYmFjayhpZGJQcm94eVRyYXBzKTtcbn1cbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gRHVlIHRvIGV4cGVjdGVkIG9iamVjdCBlcXVhbGl0eSAod2hpY2ggaXMgZW5mb3JjZWQgYnkgdGhlIGNhY2hpbmcgaW4gYHdyYXBgKSwgd2VcbiAgICAvLyBvbmx5IGNyZWF0ZSBvbmUgbmV3IGZ1bmMgcGVyIGZ1bmMuXG4gICAgLy8gQ3Vyc29yIG1ldGhvZHMgYXJlIHNwZWNpYWwsIGFzIHRoZSBiZWhhdmlvdXIgaXMgYSBsaXR0bGUgbW9yZSBkaWZmZXJlbnQgdG8gc3RhbmRhcmQgSURCLiBJblxuICAgIC8vIElEQiwgeW91IGFkdmFuY2UgdGhlIGN1cnNvciBhbmQgd2FpdCBmb3IgYSBuZXcgJ3N1Y2Nlc3MnIG9uIHRoZSBJREJSZXF1ZXN0IHRoYXQgZ2F2ZSB5b3UgdGhlXG4gICAgLy8gY3Vyc29yLiBJdCdzIGtpbmRhIGxpa2UgYSBwcm9taXNlIHRoYXQgY2FuIHJlc29sdmUgd2l0aCBtYW55IHZhbHVlcy4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyB3aXRoIHJlYWwgcHJvbWlzZXMsIHNvIGVhY2ggYWR2YW5jZSBtZXRob2RzIHJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIGN1cnNvciBvYmplY3QsIG9yXG4gICAgLy8gdW5kZWZpbmVkIGlmIHRoZSBlbmQgb2YgdGhlIGN1cnNvciBoYXMgYmVlbiByZWFjaGVkLlxuICAgIGlmIChnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpLmluY2x1ZGVzKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHRoaXMucmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgIHJldHVybiB3cmFwKGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uKHZhbHVlKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgcmV0dXJuLCBpdCBqdXN0IGNyZWF0ZXMgYSAnZG9uZScgcHJvbWlzZSBmb3IgdGhlIHRyYW5zYWN0aW9uLFxuICAgIC8vIHdoaWNoIGlzIGxhdGVyIHJldHVybmVkIGZvciB0cmFuc2FjdGlvbi5kb25lIChzZWUgaWRiT2JqZWN0SGFuZGxlcikuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pXG4gICAgICAgIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgaWYgKGluc3RhbmNlT2ZBbnkodmFsdWUsIGdldElkYlByb3h5YWJsZVR5cGVzKCkpKVxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHZhbHVlLCBpZGJQcm94eVRyYXBzKTtcbiAgICAvLyBSZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFjayBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gdHJhbnNmb3JtIGl0LlxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICAvLyBXZSBzb21ldGltZXMgZ2VuZXJhdGUgbXVsdGlwbGUgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0IChlZyB3aGVuIGN1cnNvcmluZyksIGJlY2F1c2VcbiAgICAvLyBJREIgaXMgd2VpcmQgYW5kIGEgc2luZ2xlIElEQlJlcXVlc3QgY2FuIHlpZWxkIG1hbnkgcmVzcG9uc2VzLCBzbyB0aGVzZSBjYW4ndCBiZSBjYWNoZWQuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3QodmFsdWUpO1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgdHJhbnNmb3JtZWQgdGhpcyB2YWx1ZSBiZWZvcmUsIHJldXNlIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICAvLyBUaGlzIGlzIGZhc3RlciwgYnV0IGl0IGFsc28gcHJvdmlkZXMgb2JqZWN0IGVxdWFsaXR5LlxuICAgIGlmICh0cmFuc2Zvcm1DYWNoZS5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpO1xuICAgIC8vIE5vdCBhbGwgdHlwZXMgYXJlIHRyYW5zZm9ybWVkLlxuICAgIC8vIFRoZXNlIG1heSBiZSBwcmltaXRpdmUgdHlwZXMsIHNvIHRoZXkgY2FuJ3QgYmUgV2Vha01hcCBrZXlzLlxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQobmV3VmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuY29uc3QgdW53cmFwID0gKHZhbHVlKSA9PiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcblxuLyoqXG4gKiBPcGVuIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKiBAcGFyYW0gdmVyc2lvbiBTY2hlbWEgdmVyc2lvbi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQWRkaXRpb25hbCBjYWxsYmFja3MuXG4gKi9cbmZ1bmN0aW9uIG9wZW5EQihuYW1lLCB2ZXJzaW9uLCB7IGJsb2NrZWQsIHVwZ3JhZGUsIGJsb2NraW5nLCB0ZXJtaW5hdGVkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBvcGVuUHJvbWlzZSA9IHdyYXAocmVxdWVzdCk7XG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCd1cGdyYWRlbmVlZGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlKHdyYXAocmVxdWVzdC5yZXN1bHQpLCBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCB3cmFwKHJlcXVlc3QudHJhbnNhY3Rpb24pLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgb3BlblByb21pc2VcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xuICAgICAgICBpZiAoYmxvY2tpbmcpIHtcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ3ZlcnNpb25jaGFuZ2UnLCAoZXZlbnQpID0+IGJsb2NraW5nKGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICByZXR1cm4gb3BlblByb21pc2U7XG59XG4vKipcbiAqIERlbGV0ZSBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBkZWxldGVEQihuYW1lLCB7IGJsb2NrZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKTtcbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICAvLyBNdXN0IHJlamVjdCBpZiBvcCByZWplY3RzLlxuICAgICAgICAvLyBJZiBpdCdzIGEgd3JpdGUgb3BlcmF0aW9uLCBtdXN0IHJlamVjdCBpZiB0eC5kb25lIHJlamVjdHMuXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxuICAgICAgICAvLyBNdXN0IHJlc29sdmUgd2l0aCBvcCB2YWx1ZS5cbiAgICAgICAgLy8gTXVzdCBoYW5kbGUgYm90aCBwcm9taXNlcyAobm8gdW5oYW5kbGVkIHJlamVjdGlvbnMpXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGFyZ2V0W3RhcmdldEZ1bmNOYW1lXSguLi5hcmdzKSxcbiAgICAgICAgICAgIGlzV3JpdGUgJiYgdHguZG9uZSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH07XG4gICAgY2FjaGVkTWV0aG9kcy5zZXQocHJvcCwgbWV0aG9kKTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlciksXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiAhIWdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmhhcyh0YXJnZXQsIHByb3ApLFxufSkpO1xuXG5jb25zdCBhZHZhbmNlTWV0aG9kUHJvcHMgPSBbJ2NvbnRpbnVlJywgJ2NvbnRpbnVlUHJpbWFyeUtleScsICdhZHZhbmNlJ107XG5jb25zdCBtZXRob2RNYXAgPSB7fTtcbmNvbnN0IGFkdmFuY2VSZXN1bHRzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGl0dHJQcm94aWVkQ3Vyc29yVG9PcmlnaW5hbFByb3h5ID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGN1cnNvckl0ZXJhdG9yVHJhcHMgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAoIWFkdmFuY2VNZXRob2RQcm9wcy5pbmNsdWRlcyhwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgIGxldCBjYWNoZWRGdW5jID0gbWV0aG9kTWFwW3Byb3BdO1xuICAgICAgICBpZiAoIWNhY2hlZEZ1bmMpIHtcbiAgICAgICAgICAgIGNhY2hlZEZ1bmMgPSBtZXRob2RNYXBbcHJvcF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VSZXN1bHRzLnNldCh0aGlzLCBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eS5nZXQodGhpcylbcHJvcF0oLi4uYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkRnVuYztcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRlKC4uLmFyZ3MpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdGhpcy1hc3NpZ25tZW50XG4gICAgbGV0IGN1cnNvciA9IHRoaXM7XG4gICAgaWYgKCEoY3Vyc29yIGluc3RhbmNlb2YgSURCQ3Vyc29yKSkge1xuICAgICAgICBjdXJzb3IgPSBhd2FpdCBjdXJzb3Iub3BlbkN1cnNvciguLi5hcmdzKTtcbiAgICB9XG4gICAgaWYgKCFjdXJzb3IpXG4gICAgICAgIHJldHVybjtcbiAgICBjdXJzb3IgPSBjdXJzb3I7XG4gICAgY29uc3QgcHJveGllZEN1cnNvciA9IG5ldyBQcm94eShjdXJzb3IsIGN1cnNvckl0ZXJhdG9yVHJhcHMpO1xuICAgIGl0dHJQcm94aWVkQ3Vyc29yVG9PcmlnaW5hbFByb3h5LnNldChwcm94aWVkQ3Vyc29yLCBjdXJzb3IpO1xuICAgIC8vIE1hcCB0aGlzIGRvdWJsZS1wcm94eSBiYWNrIHRvIHRoZSBvcmlnaW5hbCwgc28gb3RoZXIgY3Vyc29yIG1ldGhvZHMgd29yay5cbiAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KHByb3hpZWRDdXJzb3IsIHVud3JhcChjdXJzb3IpKTtcbiAgICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgICAgIHlpZWxkIHByb3hpZWRDdXJzb3I7XG4gICAgICAgIC8vIElmIG9uZSBvZiB0aGUgYWR2YW5jaW5nIG1ldGhvZHMgd2FzIG5vdCBjYWxsZWQsIGNhbGwgY29udGludWUoKS5cbiAgICAgICAgY3Vyc29yID0gYXdhaXQgKGFkdmFuY2VSZXN1bHRzLmdldChwcm94aWVkQ3Vyc29yKSB8fCBjdXJzb3IuY29udGludWUoKSk7XG4gICAgICAgIGFkdmFuY2VSZXN1bHRzLmRlbGV0ZShwcm94aWVkQ3Vyc29yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yUHJvcCh0YXJnZXQsIHByb3ApIHtcbiAgICByZXR1cm4gKChwcm9wID09PSBTeW1ib2wuYXN5bmNJdGVyYXRvciAmJlxuICAgICAgICBpbnN0YW5jZU9mQW55KHRhcmdldCwgW0lEQkluZGV4LCBJREJPYmplY3RTdG9yZSwgSURCQ3Vyc29yXSkpIHx8XG4gICAgICAgIChwcm9wID09PSAnaXRlcmF0ZScgJiYgaW5zdGFuY2VPZkFueSh0YXJnZXQsIFtJREJJbmRleCwgSURCT2JqZWN0U3RvcmVdKSkpO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAoaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlO1xuICAgICAgICByZXR1cm4gb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICB9LFxufSkpO1xuXG5leHBvcnQgeyBkZWxldGVEQiwgb3BlbkRCLCB1bndyYXAsIHdyYXAgfTtcbiJdLCJuYW1lcyI6WyJpbnN0YW5jZU9mQW55Iiwib2JqZWN0IiwiY29uc3RydWN0b3JzIiwic29tZSIsImMiLCJpZGJQcm94eWFibGVUeXBlcyIsImN1cnNvckFkdmFuY2VNZXRob2RzIiwiZ2V0SWRiUHJveHlhYmxlVHlwZXMiLCJJREJEYXRhYmFzZSIsIklEQk9iamVjdFN0b3JlIiwiSURCSW5kZXgiLCJJREJDdXJzb3IiLCJJREJUcmFuc2FjdGlvbiIsImdldEN1cnNvckFkdmFuY2VNZXRob2RzIiwicHJvdG90eXBlIiwiYWR2YW5jZSIsImNvbnRpbnVlIiwiY29udGludWVQcmltYXJ5S2V5IiwidHJhbnNhY3Rpb25Eb25lTWFwIiwiV2Vha01hcCIsInRyYW5zZm9ybUNhY2hlIiwicmV2ZXJzZVRyYW5zZm9ybUNhY2hlIiwicHJvbWlzaWZ5UmVxdWVzdCIsInJlcXVlc3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ1bmxpc3RlbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzdWNjZXNzIiwiZXJyb3IiLCJ3cmFwIiwicmVzdWx0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldCIsImNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbiIsInR4IiwiaGFzIiwiZG9uZSIsImNvbXBsZXRlIiwiRE9NRXhjZXB0aW9uIiwiaWRiUHJveHlUcmFwcyIsImdldCIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIm9iamVjdFN0b3JlTmFtZXMiLCJ1bmRlZmluZWQiLCJvYmplY3RTdG9yZSIsInZhbHVlIiwicmVwbGFjZVRyYXBzIiwiY2FsbGJhY2siLCJ3cmFwRnVuY3Rpb24iLCJmdW5jIiwiaW5jbHVkZXMiLCJhcmdzIiwiYXBwbHkiLCJ1bndyYXAiLCJ0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlIiwiUHJveHkiLCJJREJSZXF1ZXN0IiwibmV3VmFsdWUiLCJvcGVuREIiLCJuYW1lIiwidmVyc2lvbiIsImJsb2NrZWQiLCJ1cGdyYWRlIiwiYmxvY2tpbmciLCJ0ZXJtaW5hdGVkIiwiaW5kZXhlZERCIiwib3BlbiIsIm9wZW5Qcm9taXNlIiwiZXZlbnQiLCJvbGRWZXJzaW9uIiwibmV3VmVyc2lvbiIsInRyYW5zYWN0aW9uIiwidGhlbiIsImRiIiwiY2F0Y2giLCJkZWxldGVEQiIsImRlbGV0ZURhdGFiYXNlIiwicmVhZE1ldGhvZHMiLCJ3cml0ZU1ldGhvZHMiLCJjYWNoZWRNZXRob2RzIiwiTWFwIiwiZ2V0TWV0aG9kIiwidGFyZ2V0RnVuY05hbWUiLCJyZXBsYWNlIiwidXNlSW5kZXgiLCJpc1dyaXRlIiwibWV0aG9kIiwic3RvcmVOYW1lIiwic3RvcmUiLCJpbmRleCIsInNoaWZ0IiwiYWxsIiwib2xkVHJhcHMiLCJhZHZhbmNlTWV0aG9kUHJvcHMiLCJtZXRob2RNYXAiLCJhZHZhbmNlUmVzdWx0cyIsIml0dHJQcm94aWVkQ3Vyc29yVG9PcmlnaW5hbFByb3h5IiwiY3Vyc29ySXRlcmF0b3JUcmFwcyIsImNhY2hlZEZ1bmMiLCJpdGVyYXRlIiwiY3Vyc29yIiwib3BlbkN1cnNvciIsInByb3hpZWRDdXJzb3IiLCJkZWxldGUiLCJpc0l0ZXJhdG9yUHJvcCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/idb/build/index.js\n");

/***/ })

};
;